# -*- coding: utf-8 -*-
"""Funciones.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S6ueDwoyqHIJrFRkZ_tzlcNd6jeSXDHk
"""



# Include new columns to data set
def newcolumns(df):
  """
  Function to create necessary columns and indicators into the dataset.
  1. Identifiy resistance areas on day candles
  
  """
  
  import datetime as dt
  import numpy as np
  import pandas as pd

  # Organice and remove duplicates
  df = df.reset_index()
  df = df.drop_duplicates(
            subset = ["date"],
            keep='last'
      ).set_index("date")
  
  df = df.sort_values(
    by = ['date'], 
    ascending=True
    )

  # Define the direction of H4 candles.
  df.loc[ df['bidopen'] <= df['bidclose'], 'direction' ] = 'Up'
  df.loc[ df['bidopen'] > df['bidclose'], 'direction' ] = 'Down'

  # Velas de 4h
  df.loc[ 
       ( 
           ( ( df['bidclose'] - df['bidopen'] ) / ( df['bidhigh'] - df['bidlow'] ) ) > 0.7 
        ) & ( 
            df["direction"] == "Up" 
             ), '4h_type' ] = "Up-strong"

  df.loc[ (df["direction"] == "Down") & 
        (
            ( 
            ( df['bidopen'] - df['bidclose'] ) / ( df['bidhigh'] - df['bidlow'] )
              ) > 0.7
          ), '4h_type' 
        ] = "Down-strong"
        

  df.loc[ ( 
      (df["direction"] == "Up") & 
      (
          df['bidhigh'] - (
                      ( df['bidhigh'] - df['bidlow'] ) * 0.382
                    ) < df["bidopen"]
      ) & 
      (
          df['bidhigh'] - (
                      ( df['bidhigh'] - df['bidlow'] ) * 0.382
                    ) < df["bidclose"]
        )     
  )  , '4h_type' ] = "Up-38.2%"

  df.loc[ ( 
      (df["direction"] == "Down") & 
      (
          df['bidlow'] + (
                      ( df['bidhigh'] - df['bidlow'] ) * 0.382
                    ) > df["bidopen"]
      ) & 
      (
          df['bidlow'] + (
                      ( df['bidhigh'] - df['bidlow'] ) * 0.382
                    ) > df["bidclose"]
        )     
  )  , '4h_type' ] = "Down-38.2%"

  df.loc[ df['4h_type'].isnull(), '4h_type' ] = "indecisive"


  df["day"] = df.index.strftime('%Y-%m-%d')
  df.day = pd.to_datetime( df.day, format='%Y-%m-%d' )

  # Include an extra day for every candle that is over the close of NY market
  for a in df.index:
    if a.strftime('%H:%M:%S') >= "20:00:00":
      df.day[a] = df.day[a] + pd.to_timedelta( 1 , unit='d' )

  # Set up candle values for day time frame
  for d in df.day.unique():
    open = df[ df.index == df[ df.day == d ].index.min() ].bidopen.values[0]
    df.loc[ df.day == d , 'day_bidopen' ] =  open

    close = df[ df.index == df[ df.day == d ].index.max() ].bidclose.values[0]
    df.loc[ df.day == d , 'day_bidclose' ] =  close

    high = df[ df.day == d ].bidhigh.max()
    df.loc[ df.day == d , 'day_bidhigh' ] =  high

    low = df[ df.day == d ].bidlow.min()
    df.loc[ df.day == d , 'day_bidlow' ] =  low

    tic = df[ df.day == d ].bidlow.sum()
    df.loc[ df.day == d , 'day_tickqty' ] =  tic

  daydata = df.drop_duplicates(
        subset=['day'], 
        keep='last'
  )

  daydata = daydata.set_index("day").drop(
      columns = ['bidopen',	'bidclose',	'bidhigh',	'bidlow',	'tickqty']
  )
  
  # heikin ashi for daydata
  # Formulas https://www.investopedia.com/trading/heikin-ashi-better-candlestick/
  daydata["ha_day_bidclose"] = (daydata["day_bidopen"] + daydata["day_bidclose"] + daydata["day_bidhigh"] + daydata["day_bidlow"]) / 4 # Close of heikin ashi candle

  daydata["ha_day_bidopen"] = (
        (daydata["day_bidopen"] + daydata["day_bidclose"])/2
      ).shift(1) # Open of heikin ashi candle

  for day in daydata.index:
    daydata.loc[day, "ha_day_bidhigh"] = np.max( [ daydata["day_bidopen"].loc[day] , daydata["day_bidclose"].loc[day] , daydata["day_bidhigh"].loc[day] , daydata["day_bidlow"].loc[day] ] ) # High of heikin ashi candle
    daydata.loc[day, "ha_day_bidlow"] = np.min( [ daydata["day_bidopen"].loc[day] , daydata["day_bidclose"].loc[day] , daydata["day_bidhigh"].loc[day] , daydata["day_bidlow"].loc[day] ] ) # High of heikin ashi candle

  # Categorize each of the candles.
  daydata[ 'ha_type' ] = "indecisive"
  daydata.loc[ 
              (
                  daydata['ha_day_bidopen'] >= daydata['ha_day_bidhigh']
              ) | (
                    (( daydata['ha_day_bidhigh'] - daydata['ha_day_bidopen'] ) / ( daydata['ha_day_bidhigh'] - daydata['ha_day_bidlow'] ) <= 0.1) & ( daydata['ha_day_bidopen'] - daydata['ha_day_bidclose'] > 0 ) 
              ) , 'ha_type' ] = "down" 
  daydata.loc[ (
      daydata['ha_day_bidopen'] <= daydata['ha_day_bidlow']
      ) | (
          (( daydata['ha_day_bidopen'] - daydata['ha_day_bidlow'] ) / ( daydata['ha_day_bidhigh'] - daydata['ha_day_bidlow'] ) <= 0.1) & ( daydata['ha_day_bidopen'] - daydata['ha_day_bidclose'] < 0 )
      ) , 'ha_type' ] = "up"

  # Dataframe for data storing
  day_resistance = pd.DataFrame(
        columns=["day","bull", 'r1_top' , 'r1_bottom' , 'r2_top' , 'r2_bottom', 'last_r1_top' , 'last_r1_bottom' , 'last_r2_top' , 'last_r2_bottom']
        )
  c = 0

  # Starting metrics
  r1_top = 0.0
  r1_bottom = 0.0
  r2_top = 0.0
  r2_bottom = 0.0
  last_r1_top = 0.0
  last_r1_bottom = 0.0
  last_r2_top = 0.0
  last_r2_bottom = 0.0  
  bull = 1
  
  # Temp
  temp_max_high = 0.0
  temp_max_close = 0.0
  temp_min_low = 0.0
  temp_min_close = 0.0
  temp_r1_top = 0.0
  temp_r1_bottom = 0.0
  temp_r2_top = 0.0
  temp_r2_bottom = 0.0  

  lookback = 30

  a = 4
  while a < len(daydata.index): # start day loop
    
    if a == 4:
      temp_min_low = daydata.day_bidlow[ a - 4 : a ].min()
      temp_min_close = daydata[[ 'day_bidclose' , 'day_bidopen' ]].iloc[ a- 4 : a ].values.min()
      temp_max_high = daydata.day_bidhigh[ a - 4 : a ].max()
      temp_max_close = daydata[[ 'day_bidclose' , 'day_bidopen' ]].iloc[ a - 4 : a ].values.max()
    
    if  ( 
            daydata.ha_type[a-1] == "down" or daydata.ha_type[a-1] == "indecisive"
        ) and ( 
            daydata.ha_type[a] == "up"
        ) : # 2 down candles 3 up candles

        counter = 3
        while counter < lookback:

          if  ( 
                  daydata.ha_type[ a - counter ] == "down"  
              ) and (    
                  daydata.ha_type[ a - (counter+1) ] == "up" or  daydata.ha_type[ a - (counter + 1)] == "indecisive"
              ):

            try:
              if len(daydata.day_bidhigh[ : a ]) < counter :
                  temp_counter = len(daydata.day_bidhigh[ : a ])
              else:
                  temp_counter = counter    
                
              temp_min_low = daydata.day_bidlow[ a - temp_counter : a ].min()
              temp_min_close = daydata[[ 'day_bidclose' , 'day_bidopen' ]].iloc[ a- temp_counter : a ].values.min()
            except:
              pass
            
            break

          counter += 1

    if  ( 
            daydata.ha_type[a-1] == "up" or daydata.ha_type[a-1] == "indecisive" 
        ) and ( 
            daydata.ha_type[a] == "down"
        ) : # 2 up candles 3 down candles    

        counter = 3
        while counter < lookback:

          if  (
                  daydata.ha_type[a - (counter)] == "up"
              ) and (
                  daydata.ha_type[a - (counter+1)] == "down" or  daydata.ha_type[a - (counter + 1)] == "indecisive"
              ):
             
            try:
              if len(daydata.day_bidhigh[ : a ]) < counter :
                  temp_counter = len(daydata.day_bidhigh[ : a ])
              else:
                  temp_counter = counter
                  
              temp_max_high = daydata.day_bidhigh[ a - temp_counter : a ].max()
              temp_max_close = daydata[[ 'day_bidclose' , 'day_bidopen' ]].iloc[ a - temp_counter : a ].values.max()
            except:
              pass

            break

          counter += 1


    # define starting resistance values

    if r1_top == 0.0  : 
      r1_top = temp_max_high
      r1_bottom = temp_max_close
      last_r1_top = r1_top # Last set new resistance top
      last_r1_bottom = r1_bottom # Last set new resistance bottom
      temp_r1_top = temp_max_high
      temp_r1_bottom = temp_max_close    
    
    if r2_top == 0.0 :
      r2_top = temp_min_close
      r2_bottom = temp_min_low
      last_r2_top = r2_top # Last set new resistance top
      last_r2_bottom = r2_bottom # Last set new resistance bottom
      temp_r2_top = temp_min_close
      temp_r2_bottom = temp_min_low

    if temp_r1_bottom == 0.0: 
      temp_r1_top = temp_max_high
      temp_r1_bottom = temp_max_close

    if temp_r2_bottom == 0.0: 
      temp_r2_top = temp_min_close
      temp_r2_bottom = temp_min_low

    # define temporal resistance values for top resistance
    if temp_r1_top < temp_max_high  : 
      temp_r1_top = temp_max_high
    if temp_r1_bottom < temp_max_close  :
      temp_r1_bottom = temp_max_close
      
    # Define temporal Resistance values for bottom resistance
    if r2_bottom > temp_min_low :
      temp_r2_top = temp_min_close
    if temp_r2_bottom > temp_min_low :  
      temp_r2_bottom = temp_min_low   

    # Define bottom resistance if breack
    if daydata.day_bidclose[a] < r2_bottom :
        
      if r1_top != temp_r1_top:
          last_r1_top = r1_top # Last set new resistance top
          last_r1_bottom = r1_bottom # Last set new resistance bottom
          r1_top = temp_r1_top # set new resistance top
          r1_bottom = temp_r1_bottom # set new resistance bottom
          
      temp_r1_top = 0.0
      temp_r1_bottom = 0.0
      bull = 0
    
    # Define top resistance if breack
    if daydata.day_bidclose[a] > r1_top :
        
      if r2_top != temp_r2_top :
        last_r2_top = r2_top # Last set new resistance top
        last_r2_bottom = r2_bottom # Last set new resistance bottom
        r2_top = temp_r2_top # set new resistance top
        r2_bottom = temp_r2_bottom # set new resistance bottom
        
      temp_r2_top = 0.0
      temp_r2_bottom = 0.0
      bull = 1

    
    # Save new data in daydata dataframe
    day_resistance.loc[c] =  [ daydata.index[a] , bull , r1_top , r1_bottom , r2_top , r2_bottom , last_r1_top , last_r1_bottom , last_r2_top , last_r2_bottom  ]
    c += 1

    a += 1 # end loop

  day_resistance

  df = pd.merge(
        df.reset_index(),
        day_resistance,
        how='left',
        on='day'
        ).set_index("date")
    
  # MVA de 200
  df["MVA200"] = df.bidclose.rolling(window =200).mean()
  # Distancia al close
  # MVA 200
  df["D_MVA200"] = df.bidclose - df.MVA200

  # Calcular ATR
  high_low = df['bidhigh'] - df['bidlow']
  high_close = np.abs(df['bidhigh'] - df['bidclose'].shift())
  low_close = np.abs(df['bidlow'] - df['bidclose'].shift())

  ranges = pd.concat([high_low, high_close, low_close], axis=1)
  true_range = np.max(ranges, axis=1)

  ATR = true_range.rolling(14).sum()/14

  df["atr"] = ATR 

  return df

# Encontrar patrones de double top y bottom
def double(df):

    import datetime as dt
    import numpy as np
    import pandas as pd

    result = pd.DataFrame( )
    double = False
    data = df.tail(30) # look back window 30 days
    
    if data.direction[-1] == "Down": # Double Top
      
      a = 5
      while a <= 30:

        tempdata = data.tail(a)
        
        if tempdata.direction[0] == "Up" and tempdata.direction[1] == "Up":
          
          tempdata_counter = 1
          start = 0
          resistance_counter = 0
          first_confirmation_counter = 0
          resistance_created = False
          resistance_tested = False
          while tempdata_counter < len( tempdata.index ):

            temp1 = tempdata[ start : tempdata_counter ][['bidhigh']].values.max()  
            temp2 = tempdata[ start : tempdata_counter ][['bidopen' ,	'bidclose']].values.max()

            
            if tempdata.bidopen[tempdata_counter] < temp2 and tempdata.bidclose[tempdata_counter] < temp2 and tempdata.bidhigh[tempdata_counter] < temp2 and start == 0:
              resistance1 = temp1
              resistance2 = temp2
              start = tempdata_counter
              resistance_created = True
            
            if resistance_created and start + 1 < tempdata_counter and temp1 > resistance2  :
              resistance_tested = True
              resistance_counter = tempdata_counter

            try:
              if temp2 > resistance1:
                resistance_tested = False
                resistance_created = False
                resistance_counter = 0
                start = 0
            except:
              pass
            
            if resistance_tested and tempdata.direction[tempdata_counter] == "Down" and resistance_counter != 0 and first_confirmation_counter == 0 :
              first_confirmation_counter =  resistance_counter


            if resistance_tested and resistance_counter <= tempdata_counter and tempdata.direction[tempdata_counter] == "Down" and first_confirmation_counter == len( tempdata.index ) -1:
              double = True
              result = pd.DataFrame(
                  {
                   'length' : [tempdata_counter],
                   'heigth' : [ tempdata.bidhigh.values.max() - tempdata.bidclose[-1]  ],
                   'date' : [tempdata.index[-1]],
                   'resistance2' : [resistance2],
                   "resistance" : [resistance1],
                   'type' : ['Double Top'],
                   "entry" : [tempdata.bidclose[-1]],
                   "stop" : [tempdata.bidhigh.values.max()]
                   })
              break
              


            tempdata_counter += 1
          
        if double:
          break

        a += 1


    else: # Double Bottom
      
      a = 5
      while a <= 30:

        tempdata = data.tail(a)

        if tempdata.direction[0] == "Down" and tempdata.direction[1] == "Down":
          
          tempdata_counter = 1
          start = 0
          resistance_counter = 0
          first_confirmation_counter = 0
          resistance_created = False
          resistance_tested = False
          while tempdata_counter < len( tempdata.index ):

            temp1 = tempdata[ start : tempdata_counter ][['bidlow']].values.min()  
            temp2 = tempdata[ start : tempdata_counter ][['bidopen' ,	'bidclose']].values.min()

            
            if tempdata.bidopen[tempdata_counter] > temp2 and tempdata.bidclose[tempdata_counter] > temp2 and tempdata.bidlow[tempdata_counter] > temp2 and start == 0:
              resistance1 = temp1
              resistance2 = temp2
              start = tempdata_counter
              resistance_created = True
            
            if resistance_created and start + 1 < tempdata_counter and temp1 < resistance2  :
              resistance_tested = True
              resistance_counter = tempdata_counter

            try:
              if temp2 < resistance1:
                resistance_tested = False
                resistance_created = False
                resistance_counter = 0
                start = 0
            except:
              pass
            
            if resistance_tested and tempdata.direction[tempdata_counter] == "Up" and resistance_counter != 0 and first_confirmation_counter == 0 :
              first_confirmation_counter =  resistance_counter


            if resistance_tested and resistance_counter <= tempdata_counter and tempdata.direction[tempdata_counter] == "Up" and first_confirmation_counter == len( tempdata.index ) -1:
              double = True
              result = pd.DataFrame(
                  {
                   'length' : [tempdata_counter],
                   'heigth' : [ tempdata.bidclose[-1] - tempdata.bidlow.values.min()   ],
                   'date' : [tempdata.index[-1]],
                   'resistance2' : [resistance2],
                   "resistance" : [resistance1],
                   'type' : ['Double Bottom'],
                   "entry" : [tempdata.bidclose[-1]],
                   "stop" : [tempdata.bidlow.values.min()]
                   })
              break
              


            tempdata_counter += 1
          
        if double:
          break

        a += 1

    return result



# Funcionar para testear la ganancia v2
def gain_calculator( df_double , df_hisorical ):
    
  import datetime as dt
  import numpy as np
  import pandas as pd

  # Unir dataframe df_double con el DF principal
  df_double = pd.merge(
      df_hisorical,
      df_double,
      how='inner',
      on='date'
      )  

  df_double["gain"] = 0
  df_double["target"] = 0.0
  df_double["stop_trade"] = 0.0

  # Iteration on the patterns Data Frame
  for a in df_double.index:

    position = df_hisorical.index.get_loc( a ) # Posición en el historico donde se muestran los df_doubleados.
    temp_data = df_hisorical.iloc[ position : ] # Data historica iniciando en la posición de df_doubleado
    end = False
    
    if df_hisorical.iloc[position].direction == "Up":
      stop = df_double.stop[a] - df_double.atr[a]
      df_double.stop_trade.loc[a] = stop # Marcar el stop de cada trade
      target = df_double.entry[a] + ( df_double.heigth[a] * 2 ) + df_double.atr[a] 
      df_double["target"][a] = target

      for b in temp_data.index:
        
        if temp_data.bidclose.loc[ b ] > target:  
          df_double.gain[ a ] = 1
          end = True
          break
        
        if temp_data.bidlow.loc[ b ] < stop:
          break

    else:
      target = df_double.entry[a] - ( ( df_double.heigth[a] * 2) + df_double.atr[a] )
      stop = df_double.stop[a] + df_double.atr[a]
      df_double.stop_trade.loc[a] = stop # Marcar el stop de cada trade
      df_double["target"][a] = target

      for b in temp_data.index:

        if temp_data.bidclose.loc[ b ] < target:
          df_double.gain[ a ] = 1
          end = True
          break
        
        if temp_data.bidhigh.loc[ b ] > stop:
          break

  return df_double





# Limpiar Dataframe
def cleandataframe(df_double):

    import datetime as dt
    import numpy as np
    import pandas as pd
    
    result = df_double
    
    # Clean and optimize the data for model training and analysis
    
    # create column identifiing if the double pattern interacts is resitance or support
    result["resistance_support"] = "none"
    result.loc[ ( 
          (result.entry < result.r1_bottom) & (result.stop > result.r1_bottom )# Validate if the pattern touches and ends below the first top resistance
        ) | (
          (result.entry < result.last_r1_bottom) & (result.stop > result.last_r1_bottom) # Validate if the pattern touches and ends below the preview first top resistance         
        ) | (
          (result.entry < result.r2_bottom) & (result.stop > result.r2_bottom)  # Validate if the pattern touches and ends below the bottom resistance
        ) | (
          (result.entry < result.last_r2_bottom) & (result.stop > result.last_r2_bottom)  # Validate if the pattern touches and ends below the preview bottom resistance
        ), "resistance_support" ] = "below"

    result.loc[ ( 
          (result.entry > result.r1_top) & (result.stop < result.r1_top) # Validate if the pattern touches and ends over the first top resistance
        ) | (
            (result.entry > result.last_r1_top )& (result.stop < result.last_r1_top) # Validate if the pattern touches and ends over the preview first top resistance         
        ) | (
          (result.entry > result.r2_top) & (result.stop < result.r2_top) # Validate if the pattern touches and ends over the bottom resistance
        ) | (
          (result.entry > result.last_r2_top) & (result.stop < result.last_r2_top) # Validate if the pattern touches and ends over the preview bottom resistance
        ), "resistance_support" ] = "over"
    
    result.loc[  ( 
          (result.entry > result.r1_top) &  (result.entry < result.r1_bottom) # validate if the pattern end inside in the resistance
        ) | (
          (result.entry > result.last_r1_top) &  (result.entry < result.last_r1_bottom) # validate if the pattern end inside in the resistance
        ) | (
          (result.entry > result.r2_top) &  (result.entry < result.r2_bottom) # validate if the pattern end inside in the resistance
        ) | (
          (result.entry > result.last_r2_top) &  (result.entry < result.last_r2_bottom) # validate if the pattern end inside in the resistance
        ) , "resistance_support" ] = "inside" 
    
    result.loc[  ( 
          (result.entry > result.r1_top) &  (result.entry < result.r1_bottom) & (result.stop > result.r1_top) &  (result.stop < result.r1_bottom) # validate if the pattern is contained in the resistance
        ) | (
          (result.entry > result.last_r1_top) &  (result.entry < result.last_r1_bottom) & (result.stop > result.last_r1_top) &  (result.stop < result.last_r1_bottom) # validate if the pattern is contained in the resistance          
        ) | (
          (result.entry > result.r2_top) &  (result.entry < result.r2_bottom) & (result.stop > result.r2_top) &  (result.stop < result.r2_bottom) # validate if the pattern is contained in the resistance
        ) | (
          (result.entry > result.last_r2_top) &  (result.entry < result.last_r2_bottom) & (result.stop > result.last_r2_top) &  (result.stop < result.last_r2_bottom) # validate if the pattern is contained in the resistance
        ) , "resistance_support" ] = "contained"
    
    # create column identifiing if the MVA200 interacts pattern
    result["MVA200_interact"] = 0
    result.loc[ (
          result[["entry" , "stop" ]].max(axis=1) > result.MVA200
        ) & (
          result[["entry" , "stop" ]].min(axis=1) < result.MVA200
        ) , "MVA200_interact" ] = 1
    
    # Remove columns that doesent interact with resistance/support.
    #result = result[ result["resistance_support"] != "none" ]
    
    # Adjust movements based on the ART
    result.D_MVA200 = result.D_MVA200 / result.atr
    result.heigth = result.heigth / result.atr
    result["D_target"] = (np.max( result[["entry","target"]] , axis = 1 ) - np.min( result[["entry","target"]] , axis = 1 ))/result.atr
    result["D_stop_trade"] = (np.max( result[["entry","stop_trade"]] , axis = 1 ) - np.min( result[["entry","stop_trade"]] , axis = 1 ))/result.atr
    
    # Remove un necesary columns
    result = result.drop(
        columns = [
           'bidopen', 
           'bidclose', 
           'bidhigh', 
           'bidlow', 
           'tickqty', 
           'direction',
           '4h_type', 
           'day', 
           'day_bidopen', 
           'day_bidclose', 
           'day_bidhigh',
           'day_bidlow', 
           'day_tickqty', 
           'r1_top', 
           'r1_bottom', 
           'r2_top',
           'r2_bottom', 
           'last_r1_top', 
           'last_r1_bottom', 
           'last_r2_top',
           'last_r2_bottom',  
           'atr', 
           'resistance2',
           'resistance', 
           'MVA200'
        ]
    )  
 

    result = result.dropna()  

    return result